<?php

  //New caching request - blockchain style (cache works more efficiently when cleared, while block stays forever)
    //Block table in Ethereum
    /* 
       	- timestamp - block creation time
       	- transaction - operation done on top of data
       	- stateroot - previous linked block hashes
       	- hash - current block hash (generated by taking into account hashes of all previous blocks - https://en.wikipedia.org/wiki/Merkle_tree#/media/File:Hash_Tree.svg)
       	- previous_block_hash -> a sequence of blocks - data can be validated by cross-checking merkle tree proof with more than one node

		* in blockchain...
			transactions can be validated by each peer, by repeating transaction on top of stateroot
    */
	//Block table in this simulation
	/*	
		- time - block creation time
		- transaction - function and corresponding inputs
		- state - data object that comes out as a result (if this were to go into a real blockchain for data 	validation, it could be a hash of data object)
		- hash - merkletree(hash of state & previous block's hash) (https://blog.ethereum.org/2015/11/15/merkling-in-ethereum/)
		- previous_block_hash
		- dataview holds data relation keys contained in state (to reduce load on looking )
		- dispatch to blockchain
	*/

	//newBlock flow in this simulation
	/*
		- to-do dispatch block (to-do: merkletree implementation - script @ merkletree.php)
		- dispatch cache with only current state of the block (reduced: hash and previous_block_hash)
	*/

    function newCacheBlock(){

    	$db = $GLOBALS['db'];
    	$user_id = $GLOBALS['user_id'];
      	$input = renderInput(func_get_args());

    	if(isset($input['block']['transaction']) && isset($input['block']['dataview']) && isset($input['block']['state']) && isset($input['block']['time'])){

    		$transaction = $input['block']['transaction'];
	    	$dataview = json_encode($input['block']['dataview']);
	    	$state = json_encode($input['block']['state']);

	    	$sql = "SELECT dataview, state, unsynchronized FROM cache WHERE transaction = '{$transaction}')";

	    	$result = mysqli_query($db, $sql);
		    if($row = mysqli_fetch_array($result, MYSQLI_ASSOC)){

		    	if($row['state'] != $state || $row['dataview'] != $dataview){
	              	$sql = "UPDATE cache SET dataview = '{$dataview}', ".
	              							"object = '{$state}', ".
	              							"unsynchronized = 0, ".
	              							"time = ".time()." ".
	              						"WHERE id = '{$row['id']}'";
		    	} else {
	              	$sql = "UPDATE cache SET unsynchronized = 0, time = ".time()." WHERE id = '{$row['id']}'";
	            }
		    } else {

	          	$sql = "INSERT INTO cache (time, transaction, dataview, state, unsynchronized) VALUES (".
	          							time().', '.
	          							"'{$transaction}', ".
	          							"'{$dataview}', ".
	          							"'{$state}', ".
	          							"0); ";
			}

			if(!$row || ($row['unsynchronized'] < time() && $row['unsynchronized'] != 0)){
		    	mysqli_query($db, $sql);
			}

			newBlock($input);
		}

	    return true;
    }

    function newBlock(){ //access control, efficiency measurements
    	$db = $GLOBALS['db'];
    	$user_id = $GLOBALS['user_id'];

    	if(isset($input['block']['transaction']) && isset($input['block']['dataview']) && isset($input['block']['state']) && isset($input['block']['time'])){

    		$transaction = $input['block']['transaction'];
	    	$dataview = json_encode($input['block']['dataview']);
	    	$statehash = md5(json_encode($input['block']['state']));
	    	$time = microtime() - $input['block']['time'];

			$statehash = md5($input['block']['state']);

			//!!! missing: 
				//$hash = ... hashing with merkletree
		    	//$previous_block_hash = ...
		    	//stateroot
		    	//hash
			$sql .= "INSERT INTO block (user_id, timestamp, time, transaction, dataview, statehash) VALUES ".
	      							"'{$user_id}', ".
	      							time().', '.
	      							"'{$transaction}', ".
	      							"'{$dataview}', ".
	      							"'{$statehash}', ".
	      							"0);";
		}
    }

  //Get existing block record
    function existingCacheBlock(){

    	$db = $GLOBALS['db'];
      	$input = renderInput(func_get_args());

    	$sql = "SELECT state FROM cache WHERE transaction = '{$input['block']['transaction']}' AND (unsynchronized > ".time()." OR unsynchronized = 0)";
	    $result = mysqli_query($db, $sql);
	    if($row = mysqli_fetch_array($result, MYSQLI_ASSOC)){
	    	return json_decode($row['state']);
	    } else {
	    	return false;
	    }
    }

   	//This happens when content is added/edited
    function unsyncCache(){

    	$db = $GLOBALS['db'];
      	$input = renderInput(func_get_args());
      	$unsynchronized = $input['unsynchronized'];

      	//Blockchain simulation plugin
      	if($input['block']){

      	}

    	if(is_array($unsynchronized)){
			/*
			USAGE EXAMPLE:
			User circles updated:
				$updated['user_circle.user_id'] = $user['id'];
				$updated['circle_content_0']['circle_content.table_name'] = 'reflection';
				$updated['circle_content_0']['circle_content.entry_i'] = '11';
			*/

	    	foreach($unsynchronized AS $table_field => $key){

	    		if(!is_array($key)){
		    		$array = '"'.$table_field.'":"'.$key.'"'; //...user_id = $user['id'] in an array

		    		//Any and all caches with ("user_sphere" in "transaction") AND (user_id = $user['id'] in "object") should be unsynchronized
		    		$condition[] = "(dataview LIKE '%{$array}%')";
	    		} else {
	    			unset($condition_and);
	    			foreach($key AS $table_field_and => $key_and){
	    			    $array_and = '"'.$table_field_and.'":"'.$key_and.'"'; //tableentry_id = $user['id'] in an array

	    				$condition_and[] = "(dataview LIKE '%{$array_and}%')";
	    			}
	    			$condition[] = '('.implode(' AND ', $condition_and).')';
	    		}
	    	}
	    	$sql = "UPDATE cache SET unsynchronized = ".time()." WHERE ".implode(' OR ', $condition); //Outdating one row at a time, with OR in between
	    	mysqli_query($db, $sql);
    	}
    }

  	function formatTransaction(){
  		//With Ethereum consensus every joule of computing power is charged to the user, generating a transaction after request, soon integrated into the blockchain
      	$input = renderInput(func_get_args());

      	unset($input['user_id'])
      	unset($input['merging_block']);

    	return $function.'('.implode($args).')';
  	}

  	function mergeBlocks($merging, $merged){
  		$merging['ether']
  		return $merging;
  	}
?>