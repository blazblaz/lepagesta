<?php

//Cache works more efficiently when table has less entries and is therefore cleared, while block stays in chain forever unmodified
	//Blockchain example length ------------------------------------------------------
	//Cache example length	 	----

//With blockchain, recent data states are stored and collected from database

  //Get existing cache block - is holding cached data for specific functions, which block data state
    function existingCacheBlock(){

    	$db = $GLOBALS['db'];
      	$input = func_get_args();

    	$sql = "SELECT dataview, state FROM cache WHERE transaction = '{$input['block']['transaction']}' AND (unsynchronized > ".time()." OR unsynchronized = 0)";
	    $result = mysqli_query($db, $sql);
	    if($row = mysqli_fetch_array($result, MYSQLI_ASSOC)){
	    	$block['transaction'] = $input['block']['transaction'];
	    	$block['dataview'] = json_decode($row['dataview']);
	    	$block['state'] = json_decode($row['state']);
	    	return $block;
	    } else {
	    	return false;
	    }
    }

    function updateCacheBlock(){ //cupdateCcheBlock

    	$db = $GLOBALS['db'];
    	$user_id = $GLOBALS['user_id'];
      	$input = func_get_args();

    	if(isset($input['block']['transaction']) && isset($input['block']['dataview']) && isset($input['block']['state']) && isset($input['block']['time'])){

    		$transaction = $input['block']['transaction'];
	    	$dataview = $input['block']['dataview'] = json_encode($input['block']['dataview']);
	    	$state = $input['block']['state'] = json_encode($input['block']['state']);

	    	$sql = "SELECT dataview, state, unsynchronized FROM cache WHERE transaction = '{$transaction}')";

	    	$result = mysqli_query($db, $sql);
		    if($row = mysqli_fetch_array($result, MYSQLI_ASSOC)){

		    	if($row['state'] != $state || $row['dataview'] != $dataview){
	              	$sql = "UPDATE cache SET dataview = '{$dataview}', ".
	              							"object = '{$state}', ".
	              							"unsynchronized = 0, ".
	              							"time = ".time()." ".
	              						"WHERE id = '{$row['id']}'";
		    	} else {
	              	$sql = "UPDATE cache SET unsynchronized = 0, time = ".time()." WHERE id = '{$row['id']}'";
	            }
		    } else {

	          	$sql = "INSERT INTO cache (time, transaction, dataview, state, unsynchronized) VALUES (".
	          							time().', '.
	          							"'{$transaction}', ".
	          							"'{$dataview}', ".
	          							"'{$state}', ".
	          							"0); ";
			}

			if(!$row || ($row['unsynchronized'] < time() && $row['unsynchronized'] != 0)){
		    	mysqli_query($db, $sql);
			}

			//Blockchain simulation - dispatch block
			newBlock($input);
		}

	    return true;
    }

   	//This happens when content is added/edited
    function unsyncCache(){

    	$db = $GLOBALS['db'];
      	$input = func_get_args();

      	$unsynchronized = $input['unsynchronized'];

    	if(is_array($unsynchronized)){
			/*
			USAGE EXAMPLE:
			User circles updated:
				$updated['user_circle.user_id'] = $user['id'];
				$updated['circle_content']['circle_content.table_name'] = 'reflection';
				$updated['circle_content']['circle_content.entry_i'] = '11';
			*/
	    	foreach($unsynchronized AS $table_field => $key){
	    		if(!is_array($key)){
		    		$array = '"'.$table_field.'":"'.$key.'"'; //...user_id = $user['id'] in an array
		    		//Any and all caches with ("user_sphere" in "transaction") AND (user_id = $user['id'] in "object") should be unsynchronized
		    		$condition[] = "(dataview LIKE '%{$array}%')";
	    		} else {
	    			unset($condition_and);
	    			foreach($key AS $table_field_and => $key_and){
	    			    $array_and = '"'.$table_field_and.'":"'.$key_and.'"'; //tableentry_id = $user['id'] in an array
	    				$condition_and[] = "(dataview LIKE '%{$array_and}%')";
	    			}
	    			$condition[] = '('.implode(' AND ', $condition_and).')';
	    		}
	    	}
	    	$sql = "UPDATE cache SET unsynchronized = ".time()." WHERE ".implode(' OR ', $condition); //Outdating one row at a time, with OR in between
	    	mysqli_query($db, $sql);
    	}
    }

    //Blockchain symbolics, purpose access control, efficiency measurements
		//To-do: merkletree implementation - script is in merkletree.php)
    function newBlock(){ //With blockchain, transactions are gathered in blocks
    	$db = $GLOBALS['db'];
    	$user_id = $GLOBALS['user_id'];

    	if(isset($input['block']['transaction']) && isset($input['block']['dataview']) && isset($input['block']['state']) && isset($input['block']['time'])){

		    //Block table in Ethereum
		    /* 
		       	- timestamp - block creation time
		       	- transaction - operation done on top of data
		       	- stateroot - links to data states in previous blocks
		       	- hash - current block hash (generated by taking into account hashes of all previous blocks - https://en.wikipedia.org/wiki/Merkle_tree#/media/File:Hash_Tree.svg)
		       	- previous_block_hash -> a sequence of blocks - data can be validated by cross-checking merkle tree proof with more than one node

				* in blockchain...
					transactions can be validated by each peer, by repeating transaction on top of stateroot
		    */
			//Block table in this simulation
			/*	
				- time - block creation time
				- transaction - function and corresponding inputs
				- transaction_time - how much time processing took (microseconds)
				- state - data object that comes out as a result (if this were to go into a real blockchain to validate data, it could be a hash of data object)
				- hash - merkletree(hash of state & previous block's hash) (https://blog.ethereum.org/2015/11/15/merkling-in-ethereum/)
				- previous_block_hash
				- dataview holds data relation keys contained in state (to reduce load on looking )
				- dispatch to blockchain
			*/

	    	$statehash = md5($input['block']['state']);

  			//With Ethereum's consensus is computing power charged to the user (Ether is currency), generating a transaction after request
  			//Here, query time is logged, enabling logging changes to data as well as measuring script efficiency
	    	$transaction_time = microtime() - $input['block']['transaction_time'];

			$statehash = md5($input['block']['state']);

			$sql .= "INSERT INTO block (user_id, time, transaction, transaction_time, dataview, statehash) VALUES ".
	      							"'{$user_id}', ".
	      							time().', '.
	      							"'{$input['transaction']}', ".
	      							"'{$transaction_time}', ".
	      							"'{$input['dataview']}', ".
	      							"'{$statehash');";
		}
    }

  	function formatTransaction($input){

   		unset($input['block']);
    	return $function.'('.implode($input).')';
  	}

	function mergeBlocks($needle, $block, $buffer){

		if($pathway_parts = array_search_path($needle, $block['state'])){ //http://stackoverflow.com/users/567663/paul

			foreach ($pathway_parts as $part)
			{
			   // Possibly check if $ref[$part] is set before doing this.
			   $newBlock = &$newBlock[$part];
			}

			if($block['transaction']){ unset($buffer['transaction']); }

			$newBlock = $buffer['state'];
			unset($buffer['state']);

			$newBlock = array_merge($block, $newBlock);
			$newBlock = array_merge($newBlock, $buffer); //merge transaction & dataview
		} else {
			$newBlock = array_merge($block, $buffer);
		}

		return $newBlock;
	}
  	/*function mergeBlocks($merging, $merged){
  		$merging['ether']
  		return $merging;
  	}*/
?>