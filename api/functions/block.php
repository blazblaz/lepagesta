<?php

  //As functions querying the database are called, their stamp is attached to the transaction block
  	function transaction(){

        $input = func_get_args();

        //When function starts
        if($input['function'] && $input['route']){

    		$transaction = $input['function'].'('.json_encode($input['route']).')';
    		$buffer = 

    		$GLOBALS['transactions'][$transaction] = array(microtime() => array('route' => $input['route']));
        }

        //When function closes
        if($input['transaction']){

        	//In case more than one transaction with same parameters was called...
			foreach($GLOBALS['transactions'][$transaction] AS $start => $array){ 
				if(!$array['duration']){ //If transaction wasn't closed yet...
					$last_start = $start; //Last to open closes first (because of possible nested functions)
				}
			}
			
        	$GLOBALS['transactions'][$input['transaction']][$last_start]['duration'] = microtime() - $last_start;

        	//If data state changed get changes from state_id corresponding changes of field as compared with previous state_id
        	if($input['statechanges']){
        		$GLOBALS['transactions'][$input['transaction']][$last_start]['statechanges'] = $input['statechanges']; //taking in array('state_id', 'changed');
        	}

        	//In case transaction failed...
        	if(isset($input['status_code'] == '400')){
        		$GLOBALS['transactions'][$input['transaction']][$last_start]['status_code'] = '400';
        	}

        	$transaction = $input['transaction'];
        }

    	return $transaction;
  	}

  	//With blockchain, transactions and corresponding data state changes are gathered in blocks, linking back to blocks holding data state roots
  	//This is a relational database, where state changes are gathered in content_state table, while transactions are logged in blocks
		//To-do: merkletree implementation for data validation - script is in merkletree.php
  		//Idea for implementation: automatic post to Facebook page with block_id and hash at random time as an independent partial blockchain storage
    function newBlock(){
    	$db = $GLOBALS['db'];
    	$user_id = $GLOBALS['user_id'];
    	$entity_id = $GLOBALS['entity_id'];

    	if(isset($GLOBALS['transactions'])){

		    //Block table in Ethereum
		    /* 
		       	- timestamp - block creation time
		       	- transaction - operation done on top of data
		       	- stateroot - links to data states in previous blocks
		       	- hash - current block hash (generated by taking into account hashes of all previous blocks - https://en.wikipedia.org/wiki/Merkle_tree#/media/File:Hash_Tree.svg)
		       	- previous_block_hash -> a sequence of blocks - data can be validated by cross-checking merkle tree proof with more than one node
		       		- !!! is this 

				* in blockchain...
					transactions can be validated by each peer, by repeating functions on top of stateroot
		    */
			//Block table in this simulation
			/*	
				- user_id - user who accessed the database
				- entity_id - user acting on behalf of an entity_id
				- time - block creation time
				- transactions - high-level functions with inputs and corresponding data state changes
				- transaction_duration - how much time processing took (microseconds)
				- hash - !!! to-do - merkletree hash of "transactions" & previous block's hash

				* well, it's not exactly blockchain... it doesn't provide data validity check
					- while transactions table can provide details into every change made (outside of block table), hashes are not mirrored on a distributed database
					- thus, consensus for block validity isn't distributed among peers
					- furthermore, transactions can't be validated by repeating functions on top of stateroot
			*/

	    	$transactions = $GLOBALS['transactions'];

			foreach($GLOBALS['transactions'] AS $transaction => $array){
				$transaction_start = array_key($array);
				$start = 	(($transaction_start < $start && $start) || !$start) ? $transaction_start : $start;
				$end = 		(($array['end'] > $end && $end) || !$end) ? $array['end'] : $end;

				foreach($array['statechanges'] AS $state_id => $changed){
					$statechanges[array_key($array).'-'.$array['end']][$state_id] = $changed;
				}
			}
	    	$transaction_duration = $end - $start;

	   		$transactions = json_encode($transactions);
			$hash = md5($transactions); //!!! merkletree

			$sql.= "INSERT INTO block (user_id, entity_id, time_created, transaction_duration, transactions, hash) VALUES ".
	      							"'{$user_id}', ".
	      							"'{$entity_id}', ".
	      							time().', '.
	      							"'{$transaction_duration}', ".
	      							"'{$transactions}', ".
	      							"'{$hash}';";
			if(mysqli_query($db, $sql_content)){
	      		unset();
			}
		}
    }

?>