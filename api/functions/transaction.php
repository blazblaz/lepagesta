<?php

  //As functions querying the database are called, their stamp is attached to the block
  	function transaction($function, $parameters = NULL){

	  	//$parameters... function start: route; function end: changed states
	  	if($parameters){
	  		$transaction = $function.'('.json_encode($parameters).')';
	  	} else {
	  		$transaction = $function.'()';
	  	}
		$GLOBALS['transactions'][microtime()] = $transaction;

    	return $transaction;
  	}

  	//With blockchain, transactions and corresponding data state changes are gathered in blocks, linking back to blocks holding data state roots
  	//This is a relational database, where state changes are gathered in content_state table, while transactions are logged 
		//To-do: merkletree implementation for data validation - script is in merkletree.php
    function newTransaction(){
    	$db = $GLOBALS['db'];
    	$user_id = $GLOBALS['user_id'];
    	$entity_id = $GLOBALS['entity_id'];

    	if(isset($GLOBALS['transactions'])){

		    //Block table in Ethereum
		    /* 
		       	- timestamp - block creation time
		       	- transaction - operation done on top of data
		       	- stateroot - links to data states in previous blocks
		       	- hash - current block hash (generated by taking into account hashes of all previous blocks - https://en.wikipedia.org/wiki/Merkle_tree#/media/File:Hash_Tree.svg)
		       	- previous_block_hash -> a sequence of blocks - data can be validated by cross-checking merkle tree proof with more than one node
		       		- !!! is this 

				* in blockchain...
					transactions can be validated by each peer, by repeating functions on top of stateroot
		    */
			//Block table in this simulation
			/*	
				- user_id - user who accessed the database
				- entity_id - user acting on behalf of an entity_id
				- time - block creation time
				- transactions - high-level functions with inputs and corresponding data state changes
				- transaction_duration - how much time processing took (microseconds)
				- hash - !!! to-do - merkletree hash of "transactions" & previous block's hash

				* well, it's not exactly blockchain... it doesn't provide data validity check
					- while transactions table can provide details into every change made (outside of block table), hashes are not mirrored on a distributed database
					- thus, consensus for block validity isn't distributed among peers
					- furthermore, transactions can't be validated by repeating functions on top of stateroot
			*/

	    	$transactions = $GLOBALS['transactions'];

	    	reset($transactions);
	    	$start = current($transactions);
	    	$end = end($transactions);
	    	$transactions_duration = $end - $start;

	   		$transactions = json_encode($transactions);
			$hash = md5($transactions); //!!! merkletree

			$sql.= "INSERT INTO block (user_id, entity_id, time, transaction_duration, transactions, hash) VALUES ".
	      							"'{$user_id}', ".
	      							"'{$entity_id}', ".
	      							time().', '.
	      							"'{$transaction_duration}', ".
	      							"'{$transactions}', ".
	      							"'{$hash}';";
			if(mysqli_query($db, $sql_content)){
	      		unset();
			}
		}
    }

?>